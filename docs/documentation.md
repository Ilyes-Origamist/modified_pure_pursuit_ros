---
title: Modified Pure Pursuit
date: 2024
---

# Pure Pursuit Reference Generation and Control for a Differential Robot

The pure pursuit algorithm is a simple path-following approach commonly used in robotics. It was designed mainly for car-like robots, which have a pair of steering front wheels. To use it for a differential robot or another robotic configuration with non-holonomic constraints, it should be adapted accordingly. In this article, a simple method is proposed to establish a connection between pure pursuit, reference generation, and control input setpoints for the differential drive configuration. The classical controllers, Lyapunov-based and sliding mode, are then applied to control these setpoints. The ROS and ROS2 implementations are provided in the following GitHub repository:

https://github.com/Ilyes-Origamist/modified_pure_pursuit_ros

## Problem Formulation
In practice, we are given a set of waypoints (generated by a path planning algorithm), we want our robot to follow that path as closely as possible. It is important to distinguish between path following and trajectory tracking.     
A differential drive configuration is described by the following model:

$$
\begin{cases}
\dot{x} &= v \cos(\theta) \\
\dot{y} &= v \sin(\theta) \\
\dot{\theta} &= \omega
\end{cases}
$$    

Our goal is to compute velocity commands $v$ and $\omega$ at each time step to follow the path as accurately as possible. 

### **Trajectory Tracking Problem**     
We define a reference (virtual) mobile robot that takes linear and angular velocities $(v_r, \omega_r)$ as input and generates a desired trajectory for the real robot to follow. This reference model is known as function of time and is given by:

$$
\begin{cases}
\dot{x}_r &= v_r \cos(\theta_r) \\
\dot{y}_r &= v_r \sin(\theta_r) \\
\dot{\theta}_r &= \omega_r
\end{cases}
$$

For example, if we take $v_r$ and $\omega_r$ constant, we will have a circular trajectory.      
The goal is to drive the tracking error to 0: $e = (x_r - x, y_r - y, \theta_r - \theta) \to 0$. This can be achieved by many controllers found in litterature.


### **Path Following Problem**      
For the path tracking problem to be solved using model based control methods, the trajectory must be exactly known as function of time, which is often unavailable in practice. However, we have a path defined only by its coordinates $(x,y)$ as waypoints.       
A simple solution consists of performing interpolation of $x$ and $y$ seprately, with respect to some variable $t$. This variable will be considered proportional to the time.      
This will be used later along with pure pursuit algorithm and the robot model to generate a reference model and then used directly in the controller.




## Pure Pursuit Algorithm
For a car-like robot, the pure pursuit algorithm finds the closest path to the robot within a certain look-ahead distance. Then, compute the curvature and finally the steering angle $\delta$.

* Find the nearest point from the robot on the path $P_{nearest}$,
* Deduce the lookahead point $P_L$ from the path, located at a lookahead distance $L$ from the nearest point $P_{nearest}$,
* Compute the curvature as the inverse of the turning radius:

$$
\kappa =\frac{1}{R}=\frac{2\sin\alpha}{L}
$$

Such that:

$$
    \begin{aligned}
    \alpha& = \theta_t - \theta \\
    \theta_t &= \text{atan2}(e_x,e_y) = \text{atan2}(x_{L} - x, y_{L} - y)
    \end{aligned}
$$

* Compute the necessary control inputs to steer in that direction:
    - Steering angle for a car-like robot (Ackerman configuration):

    $$
    \delta = tan^{-1}(\kappa W_b)
    $$  

    where $W_b$ is the wheel base.
    This approach does not require a kinematic controller (outer loop) but only dynamic controller to send velocity commands to the motors.
    - Angular velocity for a differential drive. We know that $v =\omega R$ which yields to:

    $$
    \omega  = \frac{v}{R} = \kappa v
    $$

    where $v$ is the linear velocity (constant). 

## Reference Generation
The two proposed approaches are now presented, which combine the pure pursuit algorithm, generate a reference model and uses control to track that reference pose.          


### **First Approach (Experimental)**              
Firstly, the look-ahead point (goal point) represents the reference coordinates $(x_r, y_r)$ at each time stamp.

$$
(x_r(t),\, y_r(t)) = (x_L(t),\, y_L(t)) = \text{look-ahead point}
$$

Then, the reference angle is simply taken as $\theta_t$ as previously defined:

$$
\theta_r(t) = \theta_t = \text{atan2}(e_x(t),\,e_y(t))
$$

This can be explained by the fact that this angle specifies the direction towards which the robot must head.        
Now that $x_r(t)$, $y_r(t)$ and $\theta_r(t)$ are defined, we need to compute $v_r$ and $\omega_r$. A simple approach would be to use the error on orientation $e_\theta$ to increase or decrease $v$ and $\omega$. When $e_\theta$ is large, we need to decrease the linear velocity and increase the angular velocity. Worst case would be a stop and turn, i.e. $v_r = 0$, $\omega_r=-\text{sgn}(e_\theta).\omega_{\text{max}}$.     
We propose the following:

$$
\begin{aligned}
    v_r &= \begin{cases}
        v,  \quad |e_\theta| < \theta_{max}\\
        v_{min},  \quad |e_\theta| \geq \theta_{max}
    \end{cases}\\
    \omega_r&= -K_p e_{\theta}
\end{aligned}
$$


### **Second Approach (Improved)**              
This approach is different from the previous one. The only similarity is that we take the lookahead point as the reference coordinates: 

$$
(x_r(t),\, y_r(t)) = (x_L(t),\, y_L(t)) = \text{look-ahead point}
$$

Since interpolation is necessary to find the look-ahead point, it can be exploited to generate the reference velocities based on the robot's kinematics model.      

It is common to perform interpolation of $x$ and $y$ separately i.e. two splines $s_x$ and $s_y$, each with respect to a variable $t$. The idea here is to use $t$ to represent time, and given the two splines, one can easily get their derivatives $\dot s_x(t)$ and $\dot s_y(t)$ which represent an estimate of $\dot x_r(t)$ and $\dot y_r(t)$ respectively.      

Based on the robot's kinematic model, and pure pursuit, we have:

$$
\begin{aligned}
    \theta_r(t)& = \text{arctan2}\left(\hat{\dot y}_r(t), \hat{\dot x}_r(t)\right) \\
    v_r(t)&=\sqrt{\hat{\dot x}_r^2(t) + \hat{\dot y}_r^2(t)}\\
    \omega_r(t) & = \frac{v_r(t)}{R} = \frac{2\sin\alpha(t)}{L}v_r(t)
\end{aligned}
$$

Such that:

$$
\begin{aligned}
    \hat{\dot x}_r(t)& = \dot s_x(t)\\
    \hat{\dot y}_r(t)& = \dot s_y(t)
\end{aligned}
$$

And 

$$
\alpha(t) = \theta_r(t)-\theta(t)
$$

Simulation results proved the validity of this approach, but upon implementing it in ROS and simulating in Gazebo, the velocities had higher values than the robots capabilities, causing it to slip and oscillate. To solve this issue, $v_r(t)$ was scaled by a factor $\gamma$ which can be interpreted as the average linear velocity. Thus, we will have:

$$
v_r(t)= \gamma\sqrt{\hat{\dot x}_r^2(t) + \hat{\dot y}_r^2(t)}
$$

## Control (Lyapunov, Sliding Mode, PID)
Once the reference pose $(x_r, \,y_r,\,\theta_r)$ and referenec velocities $(v_r, \omega_r)$ are computed, a nonlinear controller can be used to compute the velocity control inputs $v$ and $\omega$.

### Lyapunov Controller
A Lyapunov-based controller was designed and used widely is given in \cite{old_lyap}. The control law is the following: 

$$
\begin{aligned}
    v& = v_r \cos(e_{3})+k_1e_1 \\
    \omega &= \omega_r+v_r\big(k_2e_2+k_{3}\sin(e_{3})\big)
\end{aligned}
$$

with:

$$\begin{pmatrix}
    e_1\\
    e_2\\
    e_3
\end{pmatrix}=\begin{bmatrix}
    \cos(\theta) & \sin(\theta)& 0\\
    -\sin(\theta)&\cos(\theta)& 0\\
    0 &0&1
    
\end{bmatrix}\begin{pmatrix}
    e_x\\e_y\\e_{\theta}
\end{pmatrix}=T\begin{pmatrix}
    e_x\\e_y\\e_{\theta}
\end{pmatrix}
$$

Asymptotic stability has been proved using Lyapunov theorem (with a Lyapunov candidate function).


### Sliding Mode Controller (Petrov Approach)

The key difference from the Lyapunov controller is that the objective here is to control only the **lateral error** $e_2$ and **heading error** $e_3$. The approach has been proposed by Petrov et al. in \cite{petrov}.        

For this, we choose the **closest point on the path** as reference such that the longitudinal error in the robot frame is zero:

$$
e_1 = e_x^b = 0
$$

Using this assumption, we get the reduced model: 

$$
\begin{aligned}
\dot e_2 &= v\sin(e_3) \\
\dot e_3 &= \omega_r - \omega
\end{aligned}
$$

By applying the transformation:

$$
z_1 = e_2, \qquad z_2 = \sin(e_3)
$$
we get:

$$
\begin{cases}
\dot z_1 = v z_2 \\
\dot z_2 = u
\end{cases},
\quad
u = (\omega_r - \omega)\cos(e_3)
$$


**Sliding Mode Control**    

Choose a standard sliding surface:

$$
S = z_2 + \lambda z_1, \quad \lambda > 0
$$

The switching control with saturation is:

$$
u = -\lambda v z_2 - K\,\text{sat}(S,a)
$$

which ensures exponential convergence of $ z_1 $ and $ z_2 $.

**Control Commands**    

Angular velocity:

$$
\omega = \omega_r - \frac{u}{\cos(e_3)}
$$

We take the reference angular velocity as proposed by Petrov:

$$
\omega_r = \frac{\kappa v\cos(e_3)}{1 + \kappa e_2}
$$

It may be better to use it instead of the previous equation, because the closest point on the path is involved, not the lookahead point. 

The linear velocity is taken as the one in Lyapunov controller with $e_1=0$:

$$
v = v_r \cos(e_3)
$$

with $v_r$ computed using spline derivatives as previously stated.


**Note.**  
The lateral error $e_2$ is computed using the **closest point on the path**, not the look-ahead point.


